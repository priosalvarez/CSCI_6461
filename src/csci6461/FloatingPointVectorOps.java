package csci6461;

import co.com.csci.model.Instruction;


/*Floating Point Instructions/Vector Operations:

Do not implement floating point numbers until Part IV

We have limited space in our instruction set, with only six bits for opcodes. 
So, we have to limit our floating point and vector operations. This will give 
you a chance to think about how to write a software routine to do multiplication 
and division for both floating point numbers. 

There are two floating point registers: FR0 and FR1. Each is 16 bits in length.

The format of a floating point number is the same as that for a load/store 
instruction, except that the r field takes only 2 values: 0 or 1 to specify 
the two floating point registers.

Vector operations are performed memory to memory. This was used on several 
models of vector processors as opposed to using lots of expensive registers 
to hold vectors (unless you were Seymour Cray).
*/



public class FloatingPointVectorOps {
	
	
	public void instructionFADD(Instruction instruction) throws Throwable{
		//TODO
				
		
	}	
	
	public void instructionFSUB(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	public void instructionVADD(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	public void instructionVSUB(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	public void instructionCNVRT(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	public void instructionLDFR(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	public void instructionSTFR(Instruction instruction) throws Throwable{
		//TODO
				
		
	}
	
	/*public void instructionFAULT(Instruction instruction) throws Throwable{
		//TODO
				
		
	}*/
	
	
	
	
	

}
